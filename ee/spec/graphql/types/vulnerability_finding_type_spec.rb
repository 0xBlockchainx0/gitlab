# frozen_string_literal: true

require 'spec_helper'

describe GitlabSchema.types['VulnerabilityFinding'] do
  let_it_be(:project) { create(:project) }
  let_it_be(:user) { create(:user) }
  let_it_be(:finding) { create(:vulnerabilities_occurrence) }
  let_it_be(:vulnerability) { create(:vulnerability, findings: [finding], project: project) }

  let(:fields) do
    %i[id project_fingerprint]
  end

  before do
    stub_feature_flags(first_class_vulnerabilities: true)
    stub_licensed_features(security_dashboard: true)

    project.add_developer(user)
  end

  subject { GitlabSchema.execute(query, context: { current_user: user }).as_json }

  it { expect(described_class).to have_graphql_fields(fields) }

  describe 'id' do
    let(:query) do
      %(
        query {
          project(fullPath:"#{project.full_path}") {
            vulnerabilities {
              nodes {
                findings {
                  nodes {
                    id
                  }
                }
              }
            }
          }
        }
      )
    end

    it "returns the id for all vulnerability's associated findings" do
      findings = subject.dig('data', 'project', 'vulnerabilities', 'nodes', 0, 'findings', 'nodes')
      ids = findings.pluck('id')

      expect(ids).not_to be_empty
      expect(ids).to eq(["gid://gitlab/Vulnerabilities::Occurrence/#{finding.id}"])
    end
  end

  describe 'project_fingerprint' do
    let(:query) do
      %(
        query {
          project(fullPath:"#{project.full_path}") {
            vulnerabilities {
              nodes {
                findings {
                  nodes {
                    projectFingerprint
                  }
                }
              }
            }
          }
        }
      )
    end

    it "returns the project fingerprint for all vulnerability's associated findings" do
      findings = subject.dig('data', 'project', 'vulnerabilities', 'nodes', 0, 'findings', 'nodes')
      fingerprints = findings.pluck('projectFingerprint')

      expect(fingerprints).not_to be_empty
      expect(fingerprints).to eq([finding.project_fingerprint])
    end
  end
end
